# IoTclass_project

## Chapter 1 Examples

### Example 1-1: Variable declaration and assignment  
- 변수 선언 및 할당 예제

### Example 1-2: Reassignment after declaration  
- 선언 후 재할당 예제

### Example 1-3: String and number assignment  
- 문자열 및 숫자 재할당 예제

### Example 1-4: Object creation  
- 객체 생성 예제

### Example 1-5: Object property update  
- 객체 프로퍼티 수정 예제

### Example 1-6: Object with array property  
- 배열을 포함한 객체 생성 예제

### Example 1-7: Reference assignment  
- 참조값 복사 예제

### Example 1-8: Primitive and reference difference  
- 기본형과 참조형 차이 예제

### Example 1-9: Object reassignment  
- 객체 재할당 예제

### Example 1-10: Reference copy side effect  
- 참조 복사 부작용 예제

### Example 1-11: Creating new object with same data  
- 동일 데이터의 새 객체 생성 예제

### Example 1-12: Shallow copy function  
- 얕은 복사 함수 예제

### Example 1-13: Shallow copy test  
- 얕은 복사 동작 확인 예제

### Example 1-14: Shallow copy limitation  
- 얕은 복사 한계 예제

### Example 1-15: Nested shallow copy fix  
- 중첩 얕은 복사 해결 예제

### Example 1-16: Deep copy function  
- 깊은 복사 함수 정의 예제

### Example 1-17: Deep copy test  
- 깊은 복사 동작 확인 예제

### Example 1-18: Deep copy using JSON  
- JSON 기반 깊은 복사 예제

### Example 1-19: Undefined behavior  
- undefined 동작 예제

### Example 1-20: Array creation methods  
- 배열 생성 방법 비교 예제

### Example 1-21: Sparse array methods  
- 희소 배열의 메서드 동작 예제

### Example 1-22: Null vs Undefined  
- null과 undefined 비교 예제

## Chapter 2 Examples

### Example 2-1: Variable hoisting and shadowing inside nested function
- 변수 호이스팅 및 중첩 함수 내 변수 가리기 예제

### Example 2-2: Parameter and variable declaration hoisting
- 매개변수와 변수 선언 호이스팅 예제

### Example 2-3: Variable redeclaration with overlapping names
- 변수 재선언과 이름 중복 예제

### Example 2-4: Variable hoisting with delayed assignment
- 변수 호이스팅 및 지연된 할당 예제

### Example 2-5: Conflict between variable and function hoisting
- 변수와 함수 호이스팅 간 충돌 예제

### Example 2-6: Hoisting order of function and variable declarations
- 함수와 변수 선언 호이스팅 순서 예제

### Example 2-7: Function expression hoisting with named function
- 이름 있는 함수 표현식의 호이스팅 예제

### Example 2-8: Named and anonymous function expressions
- 이름 있는 함수와 익명 함수 표현식 예제

### Example 2-9: Function declaration vs. function expression
- 함수 선언문과 함수 표현식의 호이스팅 차이 예제

### Example 2-10: Variable and function hoisting difference
- 변수와 함수 호이스팅의 차이 예제

### Example 2-11: Function redefinition and hoisting priority
- 함수 재정의와 호이스팅 우선순위 예제

### Example 2-12: Function expression overriding and hoisting behavior
- 함수 표현식 재정의와 호이스팅 동작 예제

### Example 2-13: Function expression and variable hoisting
- 함수 표현식과 변수 호이스팅 예제

### Example 2-14: Closure function inspection with console.dir
- `console.dir`을 이용한 클로저 함수 검사 예제

### Example 2-15: Closure access to outer variable and function scope
- 클로저에서 외부 변수 및 함수 접근 예제

### Example 2-16: Closure scope debugging with `debugger` keyword
- `debugger` 키워드를 이용한 클로저 스코프 디버깅 예제

## Chapter 3 Examples

### Example 3-1: `this` and `window` in the browser environment
- `this`와 `window`의 브라우저 환경에서의 동작

### Example 3-2: `this` and `global` in the Node.js environment
- `this`와 `global`의 Node.js 환경에서의 동작

### Example 3-3: Global variables and the `this` keyword
- 전역 변수와 `this` 키워드의 관계

### Example 3-4: Assigning properties to `window` and `this`
- `window`와 `this`에 속성 할당

### Example 3-5: Deleting global variables and the `this` keyword
- 전역 변수 삭제와 `this` 키워드

### Example 3-6: `this` inside a regular function and an object method
- 일반 함수와 객체 메서드에서의 `this` 동작

### Example 3-7: `this` inside an object method and using bracket notation
- 객체 메서드에서의 `this`와 대괄호 표기법 사용

### Example 3-8: `this` in nested methods inside an object
- 객체 내 중첩된 메서드에서의 `this`

### Example 3-9: `this` and the inner function inside an object method
- 객체 메서드 내의 내부 함수에서의 `this`

### Example 3-10: Using `this` in a method and in a nested function with a saved reference
- 메서드와 중첩 함수에서의 `this` 사용과 참조 저장

### Example 3-11: Arrow function and lexical `this` binding
- 화살표 함수와 렉시컬 `this` 바인딩

### Example 3-12: Using `this` with `setTimeout` and `forEach`
- `setTimeout`과 `forEach`에서의 `this`

### Example 3-13: Constructor function usage with `this`
- 생성자 함수에서의 `this` 사용

### Example 3-14: Using `call` to set `this` context
- `call`을 사용하여 `this` 컨텍스트 설정

### Example 3-15: Using `call` with method invocation
- 메서드 호출과 함께 `call` 사용

### Example 3-16: Using `apply` to set `this` context with arguments
- `apply`를 사용하여 `this` 컨텍스트와 인자 설정

### Example 3-17: Using `call` and `slice` on array-like objects
- 배열 비슷한 객체에서 `call`과 `slice` 사용

### Example 3-18: Using `arguments` with `slice` for an array-like object
- `arguments`와 `slice`를 사용하여 배열 비슷한 객체 처리

### Example 3-19: Array prototype methods on a string
- 문자열에서 배열 프로토타입 메서드 사용

### Example 3-20: Using `Array.from` to convert an array-like object to an array
- 배열 비슷한 객체를 배열로 변환하는 `Array.from` 사용

### Example 3-21: Using `call` and `apply` in inheritance
- 상속에서 `call`과 `apply` 사용

### Example 3-22: Finding the maximum and minimum values in an array
- 배열에서 최대값과 최소값 찾기

### Example 3-23: Using `Math.max` and `Math.min` with `apply`
- `apply`와 함께 `Math.max`와 `Math.min` 사용

### Example 3-24: Using spread syntax for finding max and min
- 최대값과 최소값을 찾기 위한 스프레드 문법 사용

### Example 3-25: Using `bind` to set `this` context with partial arguments
- `bind`로 `this` 컨텍스트 설정과 부분 인자 사용

### Example 3-26: Checking the name property of a function and a bound function
- 함수와 바인딩된 함수의 이름 속성 확인

### Example 3-27: Binding `this` in an inner function using `call` and `bind`
- `call`과 `bind`를 사용하여 내부 함수에서 `this` 바인딩

### Example 3-28: Using `setTimeout` with and without `bind` for `this`
- `setTimeout`에서 `this`를 `bind`와 함께 또는 없이 사용

### Example 3-29: Arrow function usage with `this` binding
- `this` 바인딩을 위한 화살표 함수 사용

### Example 3-30: Using `this` with `forEach` in an object method
- 객체 메서드에서 `forEach`와 함께 `this` 사용

### Example 3-31: Array prototype methods and their behavior
- 배열 프로토타입 메서드 및 동작

## Chapter 4 Examples

### Example 4-1: Using setInterval with inline callback  
익명 함수 기반 setInterval 사용을 통한 300ms 간격 카운터 출력 및 5회 후 정지

### Example 4-2: Using setInterval with named callback function  
이름 있는 함수 콜백을 통한 setInterval 사용과 가독성 향상

### Example 4-3: Array.map with correct parameter order  
올바른 콜백 매개변수 순서(현재값, 인덱스)를 이용한 Array.map 사용법

### Example 4-4: Array.map with incorrect parameter order  
잘못된 콜백 매개변수 순서로 인한 예기치 않은 결과 발생 사례

### Example 4-5: Custom implementation of Array.prototype.map  
for문과 콜백 호출을 활용한 Array.map 수동 구현 및 내부 동작 이해

### Example 4-6: this context in callbacks and event handlers  
콜백 함수 및 이벤트 핸들러 내 this 컨텍스트 변화 사례

### Example 4-7: this binding issues in callback functions  
객체 메서드 콜백 전달 시 this 바인딩 문제 발생 원인 분석

### Example 4-8: Preserving this with closure variable  
클로저 변수 활용을 통한 this 컨텍스트 유지 방법

### Example 4-9: Direct object method reference losing context  
직접 객체 메서드 참조 시 this 컨텍스트 손실 문제

### Example 4-10: Calling object method with different context and call usage  
메서드 다른 객체 할당 및 call 메서드 활용한 this 명시적 지정

### Example 4-11: Using bind to fix this context in callbacks  
bind 메서드를 이용한 this 컨텍스트 고정과 콜백 문제 해결

### Example 4-12: Nested callbacks with setTimeout for sequential async calls  
중첩 setTimeout을 이용한 순차적 비동기 호출 및 콜백 헬 사례

### Example 4-13: Named callback functions to avoid callback hell  
이름 있는 함수 분리로 콜백 헬 회피 및 가독성 향상

### Example 4-14: Using Promises to chain async operations  
Promise 체이닝을 이용한 비동기 작업 순차 처리

### Example 4-15: Higher-order function returning Promise functions for chaining  
고차 함수 작성 및 Promise 반환 함수 활용 체이닝 간소화

### Example 4-16: Generator function for async flow control  
Generator 함수와 yield를 통한 비동기 흐름 제어

### Example 4-17: Async/await syntax for sequential async calls  
Async/await 문법을 통한 명료한 순차적 비동기 처리

## Chapter 5 Examples

### Example 5-1: Immediate invocation of inner function  
내부 함수가 즉시 실행되면서 외부 변수 값을 캡처하여 사용함을 보여주는 예제

### Example 5-2: Returning result from inner function invocation  
내부 함수 실행 결과를 외부로 반환하고, 변수 캡처를 통해 값을 전달하는 동작 설명

### Example 5-3: Returning inner function to enable closure  
내부 함수를 반환하여 클로저(closure)를 생성하고, 이후에도 외부 변수에 접근 가능한 구조 구현

### Example 5-4: Closures in asynchronous functions and event listeners  
비동기 함수와 이벤트 리스너 내에서 클로저가 어떻게 동작하는지와 변수 캡처 방식을 보여줌

### Example 5-5: Memory release in closures with return, setInterval, and eventListener  
클로저가 참조하는 메모리 해제 방법을 반환값, setInterval, 이벤트 리스너별로 비교 분석

### Example 5-6: Closure capturing loop variable in event listeners  
반복문 내 이벤트 리스너가 클로저로 인해 동일한 변수 참조 문제를 일으키는 현상과 원인 설명

### Example 5-7: Event listener using shared callback function without closure  
클로저를 사용하지 않고 공통 콜백 함수를 이벤트 리스너에 등록하여 발생하는 한계와 특성

### Example 5-8: Event listener with bound function to fix closure issue  
bind 메서드를 활용해 클로저 문제를 해결하고, 각 이벤트 리스너가 독립적인 변수를 가지도록 구현

### Example 5-9: Factory function returning closure for event listener callbacks  
팩토리 함수가 클로저를 반환하여 이벤트 리스너마다 개별 상태를 유지하도록 하는 패턴 소개

### Example 5-10: Object literal with methods manipulating internal state  
객체 리터럴 내 메서드를 통해 내부 상태를 변경하고 접근하는 기본적인 객체지향 프로그래밍 구현

### Example 5-11: Factory function returning object with private state and getters  
프라이빗 변수와 getter를 포함한 객체를 팩토리 함수로 생성하여 캡슐화와 정보 은닉을 구현

### Example 5-12: Object.freeze를 통한 불변 객체 반환  
Object.freeze 메서드를 이용해 객체를 불변으로 만들어 상태 변경을 방지하는 기법 설명

### Example 5-13: Function binding with preset arguments using bind  
bind 함수를 사용하여 일부 인자를 고정한 새로운 함수 생성 방법과 활용 예시

### Example 5-14: Custom partial function implementation  
부분 적용(partial application)을 지원하는 커스텀 함수 구현으로, 인자 일부 고정과 재사용성 향상

### Example 5-15: Advanced partial function with placeholder support  
플레이스홀더(_)를 사용하여 인자 위치를 유동적으로 지정할 수 있는 고급 partial 함수 구현

### Example 5-16: Debounce function for event handling  
사용자 이벤트의 과도한 호출을 방지하는 디바운스 함수 구현과 실무 적용법 설명

### Example 5-17: Simple curry function for two-argument functions  
두 개 인자를 갖는 함수를 위한 단순 커리 함수 구현 및 부분 적용 활용 예제

### Example 5-18: Nested curry function for five-argument functions  
5단계 중첩 커리 함수 구현으로 다중 인자 함수에 대해 단계별 부분 적용 가능하도록 설계  

